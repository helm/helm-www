---
title: "Helm Install"
---

## helm install

Встановлює чарт

### Опис {#synopsis}

Ця команда встановлює архів чарту.

Аргумент для `install` має бути посиланням на чарт, шляхом до запакованого чарту, шляхом до розпакованої теки чарту або URL.

Щоб перезаписати значення в чартах, використовуйте прапорець `--values` та передайте файл або прапорець `--set`, щоб передати конфігурацію з командного рядка. Щоб примусово встановити значення рядка, використовуйте `--set-string`. Ви також можете використовувати `--set-file`, щоб задати окремі значення з файлу, якщо значення занадто велике для командного рядка або є динамічно згенерованим. Ви також можете використовувати `--set-json`, щоб встановити значення JSON (скаляри/обʼєкти/масиви) з командного рядка.

```shell
$ helm install -f myvalues.yaml myredis ./redis
```

або

```shell
$ helm install --set name=prod myredis ./redis
```

або

```shell
$ helm install --set-string long_int=1234567890 myredis ./redis
```

або

```shell
$ helm install --set-file my_script=dothings.sh myredis ./redis
```

або

```shell
$ helm install --set-json 'master.sidecars=[{"name":"sidecar","image":"myImage","imagePullPolicy":"Always","ports":[{"name":"portname","containerPort":1234}]}]' myredis ./redis
```

Ви можете вказати прапорець `--values`/'-f' кілька разів. Пріоритет буде наданий останньому (правому) файлу, що вказаний. Наприклад, якщо як `myvalues.yaml`, так і `override.yaml` містять ключ `Test`, значення, встановлене в `override.yaml`, матиме пріоритет:

```shell
$ helm install -f myvalues.yaml -f override.yaml myredis ./redis
```

Ви можете вказати прапорець `--set` кілька разів. Пріоритет буде наданий останньому (правому) встановленому значенню. Наприклад, якщо для ключа `foo` встановлені значення `bar` і `newbar`, значення `newbar` матиме пріоритет:

```shell
$ helm install --set foo=bar --set foo=newbar myredis ./redis
```

Аналогічно, у наступному прикладі `foo` встановлено в `["four"]`:

```shell
$ helm install --set-json='foo=["one", "two", "three"]' --set-json='foo=["four"]' myredis ./redis
```

А в наступному прикладі `foo` встановлено в `{"key1":"value1","key2":"bar"}`:

```shell
$ helm install --set-json='foo={"key1":"value1","key2":"value2"}' --set-json='foo.key2="bar"' myredis ./redis
```

Щоб перевірити згенеровані маніфести релізу без встановлення чарту, можна поєднати прапорці `--debug` і `--dry-run`.

Якщо встановлено прапорець `--verify`, чарт ПОВИНЕН мати файл автентифікації, і цей файл ПОВИНЕН пройти всі кроки перевірки.

Є шість різних способів казати чарт, який ви хочете встановити:

1. З посиланням на чарт: `helm install mymaria example/mariadb`
2. З шляхом до запакованого чарту: `helm install mynginx ./nginx-1.2.3.tgz`
3. З шляхом до розпакованої теки чарту: `helm install mynginx ./nginx`
4. З абсолютним URL: `helm install mynginx https://example.com/charts/nginx-1.2.3.tgz`
5. З посиланням на чарт і URL репозиторію: `helm install --repo https://example.com/charts/ mynginx nginx`
6. З OCI реєстрами: `helm install mynginx --version 1.2.3 oci://example.com/charts/nginx`

ПОСИЛАННЯ НА ЧАРТ

Посилання на чарт — це зручний спосіб посилатися на чарт у репозиторії чарту.

Коли ви використовуєте посилання на чарт з префіксом репозиторію (`example/mariadb`), Helm шукатиме в локальній конфігурації репозиторій чарту з імʼям `example`, а потім шукатиме чарт у цьому репозиторії, чия назва є `mariadb`. Він встановить останню стабільну версію цього чарту, поки ви не вкажете прапорець `--devel`, щоб також включити версії розробки (альфа, бета та реліз-кандидати), або не надасте номер версії за допомогою прапорця `--version`.

Щоб переглянути список репозиторіїв чартів, використовуйте `helm repo list`. Щоб шукати чарти в репозиторії, використовуйте `helm search`.

```shell
helm install [NAME] [CHART] [flags]
```

### Параметри {#options}

```none
      --atomic                                     якщо вказано, процес встановлення видалить всnановлення у разі невдачі. Прапорець --wait буде встановлено автоматично, якщо використовується --atomic
      --ca-file string                             перевірити сертифікати HTTPS-серверів за допомогою цього CA пакету
      --cert-file string                           ідентифікувати клієнта HTTPS, використовуючи цей файл SSL сертифікату
      --create-namespace                           створити простір імен релізу, якщо його не існує
      --description string                         додати власний опис
      --devel                                      використовувати також версії в розробці. Еквівалент версії '>0.0.0-0'. Якщо вказано --version, цей параметр ігнорується.
      --disable-openapi-validation                 якщо вказано, процес встановлення не буде перевіряти відрендерені шаблони за схемою OpenAPI Kubernetes
      --dry-run string[="client"]                  імітувати встановлення. Якщо --dry-run вказано без жодної опції або як '--dry-run=client', він не буде намагатися підключитися до кластера. Встановлення '--dry-run=server' дозволяє намагатися підключитися до кластера.
      --enable-dns                                 увімкнути DNS запити при рендерингу шаблонів
      --force                                      примусово оновлювати ресурси через стратегію заміни
  -g, --generate-name                              згенерувати імʼя (та опустити параметр NAME)
  -h, --help                                       довідка install
      --insecure-skip-tls-verify                   пропустити перевірку сертифікатів TLS для завантаження чарту
      --key-file string                            ідентифікувати клієнта HTTPS за допомогою цього SSL ключового файлу
      --keyring string                             розташування публічних ключів, що використовуються для перевірки (стандартно "~/.gnupg/pubring.gpg")
  -l, --labels stringToString                      Мітки, які будуть додані до метаданих релізу. Мають бути розділені комами. (стандартно [])
      --name-template string                       вказати шаблон для назви релізу
      --no-hooks                                   запобігти виконанню хуків під час встановлення
  -o, --output format                              виводить результат у вказаному форматі. Дозволені значення: table, json, yaml (стандартно table)
      --pass-credentials                           передати облікові дані всім доменам
      --password string                            пароль до репозиторію чартів, де розташований запитуваний чарт
      --plain-http                                 використовувати небезпечні HTTP зʼєднання для завантаження чарту
      --post-renderer postRendererString           шлях до виконуваного файлу, що використовується для пост-рендерингу. Якщо він існує в $PATH, буде використано двійковий файл, в іншому випадку буде намагатися знайти виконуваний файл за вказаним шляхом
      --post-renderer-args postRendererArgsSlice   аргумент до пост-рендерера (можна вказати кілька) (стандартно [])
      --render-subchart-notes                      якщо вказано, рендерити нотатки субчартів разом з батьківським
      --replace                                    повторно використовувати дане імʼя, тільки якщо це імʼя є вилученим релізом, який залишається в і єсторії. Це є небезпечним в операційному середовищі
      --repo string                                URL репозиторію чартів, де розташований запитуваний чарт
      --set stringArray                            встановити значення в командному рядку (можна вказати кілька або розділити значення комами: key1=val1,key2=val2)
      --set-file stringArray                       встановити значення з відповідних файлів, що вказані через командний рядок (можна вказати кілька або розділити значення комами: key1=path1,key2=pshellath2)
      --set-json stringArray                       встановити значення JSON в командному рядку (можна вказати кілька або розділити значення комами: key1=jsonval1,key2=jsonval2)
      --set-literal stringArray                    встановити літеральне значення STRING в командному рядку
      --set-string stringArray                     встановити значення STRING на командному рядку (можна вказати кілька або розділити значення комами: key1=val1,key2=val2)
      --skip-crds                                  якщо вказано, CRD не буде встановлено. Стандартно CRD встановлюються, якщо їх ще немає
      --timeout duration                           час очікування для будь-якої окремої операції Kubernetes (наприклад, Jobs для хуків) (стандартно 5м0с)
      --username string                            імʼя користувача репозиторію чартів, де розташований запитуваний чарт
  -f, --values strings                             вказати значення в YAML файлі або URL (можна вказати кілька)
      --verify                                     перевірити пакет перед використанням
      --version string                             вказати обмеження версії для версії чарта, яку слід використовувати. Це обмеження може бути конкретним теґом (наприклад, 1.1.1) або може посилатися на допустимий діапазон (наприклад, ^2.0.0). Якщо це не вказано, використовується остання версія
      --wait                                       якщо вказано, буде чекати, поки всі Pods, PVCs, Сервіси і мінімальна кількість Pods Deployment, StatefulSet або ReplicaSet не будуть готові перед позначенням релізу як успішного. Чекати буде стільки, скільки встановлено --timeout
      --wait-for-jobs                              якщо вказано і --wait увімкнено, чекатиме, поки всі Jobs не будуть завершені перед позначенням релізу як успішного. Чекати буде стільки, скільки встановлено --timeout
```

### Параметри, успадковані від батьківських команд {#options-inherited-from-parent-commands}

```none
      --burst-limit int                 стандартні обмеження на стороні клієнта (стандартно 100)
      --debug                           увімкнути розширений вивід
      --kube-apiserver string           адреса та порт сервера API Kubernetes
      --kube-as-group stringArray       група для імперсонації під час операції, цей прапор може бути повторений для вказання кількох груп.
      --kube-as-user string             імʼя користувача для імперсонації під час операції
      --kube-ca-file string             файл центру сертифікаці СА для підключення до сервера API Kubernetes
      --kube-context string             імʼя контексту kubeconfig для використання
      --kube-insecure-skip-tls-verify   якщо встановлено true, сертифікат сервера API Kubernetes не буде перевірятися на дійсність. Це робить ваші HTTPS-зʼєднання небезпечними
      --kube-tls-server-name string     імʼя сервера для перевірки сертифіката сервера API Kubernetes. Якщо не вказано, використовується імʼя хоста, що використовується для підключення до сервера
      --kube-token string               токен на предʼявника, який використовується для автентифікації
      --kubeconfig string               шлях до файлу kubeconfig
  -n, --namespace string                простір імен для цього запиту
      --qps float32                     кількість запитів в секунду під час взаємодії з API Kubernetes, не включаючи сплески
      --registry-config string          шлях до файлу конфігурації реєстру (стандартно "~/.config/helm/registry/config.json")
      --repository-cache string         шлях до файлу, що містить кешовані індекси репозиторіїв (стандартно "~/.cache/helm/repository")
      --repository-config string        шлях до файлу, що містить імена та URL репозиторіїв (стандартно "~/.config/helm/repositories.yaml")
```

### ДИВІТЬСЯ ТАКОЖ {#see-also}

* [helm](helm.md) — Менеджер пакетів Helm для Kubernetes.

###### Автоматично згенеровано spf13/cobra 24 січня 2024
