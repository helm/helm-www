---
title: "역할 기반 접근 제어"
description: "헬름이 쿠버네티스의 역할 기반 접근 제어와 상호 작용하는 방법을 설명한다."
weight: 11
---

쿠버네티스에서 사용자 또는 애플리케이션별 서비스 계정에 
역할을 부여하는 것은 애플리케이션이 지정한 권한범위 내에서 작동하도록 
하는 모범 사례이다. [공식 쿠버네티스 
문서에서](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#service-account-permissions) 서비스 계정 권한에 대해 
자세히 알아보도록 하자.

쿠버네티스 1.6 부터는 역할 기반 접근 제어(RBAC)가 기본적으로 활성화된다.
RBAC을 사용하면 조직에서 사용자와 역할에 따라 허용되는
작업유형을 지정할 수 있다.

RBAC을 사용하여, 사용자는 다음을 수행할 수 있다.

- 관리자에게 특별 작업권한(새 역할과 같은 클러스터 전체 리소스 생성)을 
  부여한다.
- 리소스(파드, 퍼시스턴트 볼륨, 
  디플로이먼트)를 생성하는 사용자의 권한을 특정 네임스페이스 또는 클러스터 전체 범위(리소스 
  할당량, 역할, 사용자 지정 리소스 정의)로 제한한다.
- 특정 네임스페이스 또는 클러스터 전체 범위에서 리소스를 볼 수 있는 사용자의
  권한을 제한한다.

이 가이드는 사용자와 쿠버네티스 API 의 상호작용 범위를 제한하려는
관리자를 위한 것이다.

## 사용자 계정 관리

모든 쿠버네티스 클러스터에는 2가지 사용자 카테고리가 있다: 일반 사용자와 쿠버네티스가 관리하는
서비스 계정

일반 사용자는 외부의 독립적인 서비스에 의해 관리되는 것으로 간주한다. 관리자가 개인키를 
발급해주면, 사용자는 키스톤이나 구글 어카운트(Google Accounts)에 보관하거나 그냥
사용자 이름 및 비밀번호 목록을 파일에 보관할 수도 있다. 이와 관련하여 쿠버네티스에는 
일반 사용자 계정을 나타내는 객체가 없다. 일반 사용자는 
API 호출을 통해 클러스터에 추가될 수 없다.

반대로 서비스 계정은 쿠버네티스 API로 관리되는 사용자이다. 특정 
네임스페이스에 바인딩 되며 API 서버에 의해 자동으로 생성되거나 
API 호출을 통해 수동으로 생성된다. 서비스 계정은 시크릿으로 
저장된 자격증명 집합에 연결되어 있으며, 파드에 마운트되어 클러스터 
내 프로세스가 쿠버네티스 API와 통신할 수 있도록 한다.

API 요청은 일반 사용자 또는 서비스 계정에 연결되거나 
익명의 요청으로 처리된다. 즉, 워크스테이션에서 `kubectl` 을 
입력하는 실제 사용자, 노드의 kubelet, 컨트롤 플레인의 구성원에 
이르기까지 클러스터 내부 또는 외부의 모든 프로세스는 API 서버에 요청할 때 
인증을 받거나 익명의 사용자로 취급되어야 한다는 것을 의미한다. 

## 롤, 클러스터롤, 롤바인딩, 클러스터롤바인딩

쿠버네티스에서 사용자 계정 및 서비스 계정은 
접근 권한이 부여된 리소스만을 보고 편집할 수 있다. 
이 접근은 롤 및 롤바인딩을 통해 부여된다. 롤 및 롤바인딩은 
특정 네임스페이스에 바인딩되어 롤이 사용자에게 접근을 제공하는 
동안 네임스페이스 내의 리소스를 보거나 편집할 수 있는 권한이 부여된다.

클러스터 범위에서는 이를 클러스터롤 및 클러스터롤바인딩이라고 한다. 
사용자에게 클러스터롤을 부여하면 전체 클러스터에서 리소스를 보거나 
편집할 수 있는 접근 권한이 부여된다. 또한 클러스터 범위(네임스페이스, 
리소스 할당량, 노드)에서 리소스를 보거나 편집할 수 있다.

클러스터롤은 롤바인딩의 참조를 통해 특정 네임스페이스에 바인딩 
될 수 있다. `admin`, `edit` 및 `view` 기본 클러스터롤은 
일반적으로 이러한 방식으로 사용된다.

쿠버네티스에서 기본적으로 사용할 수 있는 몇가지 클러스터롤들이 있다. 이는 
사용자와 직접 연계하기 위해서이다. 여기에는 super-user 롤 
(`cluster-admin`)과 더 세분화된 접근 권한(`admin`, `edit`, 
`view`)이 포함된다.

| 기본 클러스터롤           | 기본 클러스터롤바인딩              | 설명
|---------------------|----------------------------|-------------
| `cluster-admin`     | `system:masters` group     | super-user를 허용하여 모든 리소스에서 작업을 수행할 수 있다. 클러스터롤바인딩에서 사용하면 클러스터 및 모든 네임스페이스의 모든 리소스를 완전히 제어할 수 있다. 롤바인딩에서 사용하면 네임스페이스 자체를 포함하여 롤바인딩의 네임스페이스에 있는 모든 리소스에 대한 모든 권한을 제공한다.
| `admin`             | None                       | 롤바인딩을 사용하여 네임스페이스 내에서 부여되도록 의도된 관리자 접근을 허용한다. 롤바인딩에서 사용되는 경우 네임스페이스 내에서 롤 및 롤바인딩을 만드는 기능을 포함하여 네임스페이스의 대부분의 리소스에 대한 읽기/쓰기 접근을 허용한다. 리소스 할당량 또는 네임스페이스 자체에 대한 쓰기 접근은 허용하지 않는다.
| `edit`              | None                       | 네임스페이스에 있는 대부분의 오브젝트에 대한 읽기/쓰기 접근을 허용한다. 롤 및 롤바인딩을 보거나 수정할수는 없다.
| `view`              | None                       | 읽기 전용 접근을 허용하여 네임스페이스에 있는 대부분의 오브젝트를 볼 수 있다. 롤 및 롤바인딩을 보는 것은 허용되지 않는다. 마찬가지로 시크릿을 보는 것은 허용되지 않는다.

## RBAC을 사용하여 사용자 계정의 접근 제한하기

이제 역할 기반 접근의 기본 사항을 이해했으므로, 관리자가 사용자의 접근 범위를
제한하는 방법에 대해 알아보자.

### 예: 사용자에게 특정 네임스페이스에 대한 읽기/쓰기 접근 권한 부여하기

특정 네임스페이스에 대한 사용자의 접근을 제한하려면 `edit` 또는 `admin` 
롤을 사용할 수 있다. 차트가 롤 및 롤바인딩을 생성하거나 상호작용하는 경우 
`admin` 클러스터롤을 사용하는 것이 좋다.

또한 `cluster-admin` 접근 권한으로 롤바인딩을 만들 수도 있다. 
네임스페이스 범위에서 사용자에게 `cluster-admin` 접근 권한을 부여하면 
네임스페이스 자체를 포함하여 네임스페이스의 모든 리소스를 완전히 제어할 수 있다.

이 예시에서는 `edit` 역할을 가진 사용자를 생성한다. 먼저 네임스페이스를
만든다.

```console
$ kubectl create namespace foo
```

이제 해당 네임스페이스에 롤바인딩을 만들어서 사용자에게 `edit` 롤을 부여한다.

```console
$ kubectl create rolebinding sam-edit
    --clusterrole edit \​
    --user sam \​
    --namespace foo
```

### 예: 사용자에게 클러스터 범위에서 읽기/쓰기 접근 권한 부여하기

사용자가 클러스터 범위 리소스
(네임스페이스, 롤, 사용자 지정 리소스 정의 등)를 
설치하는 차트를 설치하려는 경우, 클러스터 범위의 쓰기 접근이 필요하다.

이를 위해 사용자에게 `admin` 또는 `cluster-admin` 접근 권한을 부여한다.

사용자에게 `cluster-admin` 접근 권한을 부여하면 
`kubectl drain` 을 사용한 노드 접근 및 기타 관리 작업을 
포함하여 쿠버네티스에서 사용할 수 있는 모든 리소스에 대한 접근 권한이 
부여된다. 이 방식보다는 사용자에 `admin` 접근을 제공하거나 필요에 
맞는 사용자 지정 클러스터롤을 생성하는 것을 권장한다.

```console
$ kubectl create clusterrolebinding sam-view
    --clusterrole view \​
    --user sam

$ kubectl create clusterrolebinding sam-secret-reader
    --clusterrole secret-reader \​
    --user sam
```

### 예: 사용자에게 특정 네임스페이스에 대한 읽기 전용 접근 권한 부여하기

시크릿을 볼 수 있는 클러스터롤이 없다는 것을 알아챘을지도 모르겠다.
`view` 클러스터롤은 에스컬레이션 문제로 인해 사용자에게 시크릿에 
대한 읽기 접근 권한을 부여하지 않는다. 헬름은 기본적으로 릴리스 메타 데이터를 시크릿으로 저장한다.

사용자가 `helm list` 를 실행하려면 이러한 시크릿을 읽을 수 있어야 한다. 이를 위해
특별한 `secret-reader` 클러스터롤을 생성한다.

`cluster-role-secret-reader.yaml` 파일을 만들고 아래의 
내용을 파일에 작성한다.

```yaml
apiVersion: rbac.authorization.k8s.io/v1​
kind: ClusterRole​
metadata:​
  name: secret-reader​
rules:​
- apiGroups: [""]​
  resources: ["secrets"]​
  verbs: ["get", "watch", "list"]
```

그러고 나서, 다음을 사용하여 클러스터롤을 만든다.

```console
$ kubectl create -f clusterrole-secret-reader.yaml​
```

완료되면 사용자에게 대부분의 리소스에 대한 접근 권한을 부여한 다음 시크릿에 대한
읽기 접근 권한을 부여할 수 있다.

```console
$ kubectl create namespace foo

$ kubectl create rolebinding sam-view
    --clusterrole view \​
    --user sam \​
    --namespace foo

$ kubectl create rolebinding sam-secret-reader
    --clusterrole secret-reader \​
    --user sam \​
    --namespace foo
```

### 예: 클러스터 범위에서 사용자에게 읽기전용 접근 권한 부여하기

특정 시나리오에서는 사용자에게 클러스터 범위 접근 권한을 부여하는 것이 유용할 수 있다. 
예를 들어 사용자가 `helm list --all-namespaces` 명령을 
실행하려는 경우 API는 사용자에게 클러스터 범위 읽기 접근 권한이 있어야 한다.

그렇게 하려면 위에서 설명한대로 사용자에게 `view` 및 `secret-reader` 접근 권한을 
부여하되, 클러스터롤바인딩을 사용한다.

```console
$ kubectl create clusterrolebinding sam-view
    --clusterrole view \​
    --user sam

$ kubectl create clusterrolebinding sam-secret-reader
    --clusterrole secret-reader \​
    --user sam
```

## 추가적인 고려사항

위에 표시된 예는 쿠버네티스와 함께 제공되는 기본 클러스터롤을 
활용한다. 사용자에게 접근 권한이 부여된 리소스를 더 세밀하게 
제어하려면 고유한 사용자 지정 역할 및 클러스터롤 생성에 대한 
[쿠버네티스 문서](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)를 
참조하자.
