---
title: Архітектура Helm
description: Описує архітектуру Helm на високому рівні.
sidebar_position: 8
---

# Архітектура Helm {#helm-architecture}

Цей документ описує архітектуру Helm на високому рівні.

## Призначення Helm {#the-purpose-of-helm}

Helm — це інструмент для керування пакетами Kubernetes, що називаються _чартами_. Helm може:

- Створювати нові чарти з нуля
- Упаковувати чарт в архіви чартів (tgz)
- Взаємодіяти з репозиторіями чартів, де зберігаються чарти
- Встановлювати та видаляти чарти в наявному кластері Kubernetes
- Керувати циклом випуску чартів, які були встановлені за допомогою Helm

Для Helm є три важливі концепції:

1. _Chart_ — це пакет інформації, необхідної для створення екземпляра застосунку Kubernetes.
2. _Config_ містить конфігураційну інформацію, яку можна обʼєднати з упакованим чартом для створення обʼєкта, що підлягає випуску.
3. _Release_ — це запущений екземпляр _чарту_, поєднаний з конкретним _конфігом_.

## Компоненти {#components}

Helm є виконуваним файлом, який реалізовано в двох окремих частинах:

**Клієнт Helm** — це клієнт командного рядка для кінцевих користувачів. Клієнт відповідає за:

- Розробку локальних чартів
- Керування репозиторіями
- Керування випусками
- Взаємодію з бібліотекою Helm
  - Надсилання чартів для встановлення
  - Запит на оновлення або видалення наявних випусків

**Бібліотека Helm** надає логіку для виконання всіх операцій Helm. Вона взаємодіє з API-сервером Kubernetes і забезпечує такі можливості:

- Обʼєднання чарту і конфігурації для створення випуску
- Встановлення чартів у Kubernetes і надання наступного обʼєкта випуску
- Оновлення та видалення чартів шляхом взаємодії з Kubernetes

Окрема бібліотека Helm інкапсулює логіку Helm, щоб її можна було використовувати різними клієнтами.

## Реалізація {#implementation}

Клієнт та бібліотека Helm написані мовою програмування Go.

Бібліотека використовує клієнтську бібліотеку Kubernetes для комунікації з Kubernetes.Зараз ця бібліотека використовує REST+JSON. Інформація зберігається у Secrets, розташованих всередині Kubernetes. Вона не потребує власної бази даних.

Конфігураційні файли, коли це можливо, написані у YAML.
