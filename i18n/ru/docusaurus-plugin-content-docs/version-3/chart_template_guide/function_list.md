---
title: Список функций шаблонов
description: Список функций шаблонов, доступных в Helm
sidebar_position: 6
---

Helm включает множество функций шаблонов, которые вы можете использовать в шаблонах.
Они перечислены здесь и разбиты на следующие категории:

* [Криптографические функции и функции безопасности](#криптографические-функции-и-функции-безопасности)
* [Функции даты](#функции-даты)
* [Словари](#словари-и-функции-dict)
* [Функции кодирования](#функции-кодирования)
* [Функции путей файлов](#функции-путей-файлов)
* [Функции Kubernetes и Chart](#функции-kubernetes-и-chart)
* [Логика и управление потоком](#функции-логики-и-управления-потоком)
* [Списки](#списки-и-функции-list)
* [Математические функции](#математические-функции)
* [Математические функции с плавающей точкой](#математические-функции-с-плавающей-точкой)
* [Сетевые функции](#сетевые-функции)
* [Функции рефлексии](#функции-рефлексии)
* [Регулярные выражения](#регулярные-выражения)
* [Семантические версии](#функции-семантических-версий)
* [Строковые функции](#строковые-функции)
* [Функции преобразования типов](#функции-преобразования-типов)
* [URL-функции](#url-функции)
* [UUID-функции](#uuid-функции)

## Функции логики и управления потоком

Helm включает множество функций логики и управления потоком, включая [and](#and),
[coalesce](#coalesce), [default](#default), [empty](#empty), [eq](#eq),
[fail](#fail), [ge](#ge), [gt](#gt), [le](#le), [lt](#lt), [ne](#ne),
[not](#not), [or](#or) и [required](#required).

### and

Возвращает логическое И двух или более аргументов
(первый пустой аргумент или последний аргумент).

```
and .Arg1 .Arg2
```

### or

Возвращает логическое ИЛИ двух или более аргументов
(первый непустой аргумент или последний аргумент).

```
or .Arg1 .Arg2
```

### not

Возвращает логическое отрицание аргумента.

```
not .Arg
```

### eq

Возвращает логическое равенство аргументов (например, Arg1 == Arg2).

```
eq .Arg1 .Arg2
```

### ne

Возвращает логическое неравенство аргументов (например, Arg1 != Arg2)

```
ne .Arg1 .Arg2
```

### lt

Возвращает `true`, если первый аргумент меньше второго. В противном случае
возвращается `false` (например, Arg1 < Arg2).

```
lt .Arg1 .Arg2
```

### le

Возвращает `true`, если первый аргумент меньше или равен второму.
В противном случае возвращается `false` (например, Arg1 <= Arg2).

```
le .Arg1 .Arg2
```

### gt

Возвращает `true`, если первый аргумент больше второго. В противном случае
возвращается `false` (например, Arg1 > Arg2).

```
gt .Arg1 .Arg2
```

### ge

Возвращает `true`, если первый аргумент больше или равен второму.
В противном случае возвращается `false` (например, Arg1 >= Arg2).

```
ge .Arg1 .Arg2
```

### default

Чтобы задать простое значение по умолчанию, используйте `default`:

```
default "foo" .Bar
```

Выше, если `.Bar` имеет непустое значение, оно будет использовано. Если же
оно пустое, вместо него будет возвращено `foo`.

Определение «пустого» зависит от типа:

- Числовые: 0
- Строки: ""
- Списки: `[]`
- Словари: `{}`
- Логические: `false`
- И всегда `nil` (также называемый null)

Для структур определения пустоты не существует, поэтому структура никогда
не вернёт значение по умолчанию.

### required

Укажите значения, которые должны быть заданы, с помощью `required`:

```
required "A valid foo is required!" .Bar
```

Если `.Bar` пустой или не определён (см. [default](#default) о том, как это
вычисляется), шаблон не будет отрисован и вместо этого будет возвращено
указанное сообщение об ошибке.

### empty

Функция `empty` возвращает `true`, если данное значение считается пустым, и
`false` в противном случае. Пустые значения перечислены в разделе `default`.

```
empty .Foo
```

Обратите внимание, что в условных конструкциях шаблонов Go пустота вычисляется
автоматически. Поэтому вам редко нужен `if not empty .Foo`. Вместо этого
используйте просто `if .Foo`.

### fail

Безусловно возвращает пустую строку (`string`) и ошибку (`error`) с указанным
текстом. Это полезно в сценариях, когда другие условия определили, что
отрисовка шаблона должна завершиться неудачей.

```
fail "Please accept the end user license agreement"
```

### coalesce

Функция `coalesce` принимает список значений и возвращает первое непустое
из них.

```
coalesce 0 1 2
```

Вернёт `1`.

Эта функция полезна для проверки нескольких переменных или значений:

```
coalesce .name .parent.name "Matt"
```

Выше сначала проверяется, пусто ли `.name`. Если нет, это значение будет
возвращено. Если оно _пустое_, `coalesce` проверит `.parent.name` на пустоту.
Наконец, если и `.name`, и `.parent.name` пусты, будет возвращено `Matt`.

### ternary

Функция `ternary` принимает два значения и тестовое значение. Если тестовое
значение истинно, возвращается первое значение. Если тестовое значение пустое,
возвращается второе значение. Это похоже на тернарный оператор в C и других
языках программирования.

#### Истинное тестовое значение

```
ternary "foo" "bar" true
```

или

```
true | ternary "foo" "bar"
```

Выше возвращается `"foo"`.

#### Ложное тестовое значение

```
ternary "foo" "bar" false
```

или

```
false | ternary "foo" "bar"
```

Выше возвращается `"bar"`.

## Строковые функции

Helm включает следующие строковые функции: [abbrev](#abbrev),
[abbrevboth](#abbrevboth), [camelcase](#camelcase), [cat](#cat),
[contains](#contains), [hasPrefix](#hasprefix-и-hassuffix),
[hasSuffix](#hasprefix-и-hassuffix), [indent](#indent), [initials](#initials),
[kebabcase](#kebabcase), [lower](#lower), [nindent](#nindent),
[nospace](#nospace), [plural](#plural), [print](#print), [printf](#printf),
[println](#println), [quote](#quote-и-squote),
[randAlpha](#randalphanum-randalpha-randnumeric-и-randascii),
[randAlphaNum](#randalphanum-randalpha-randnumeric-и-randascii),
[randAscii](#randalphanum-randalpha-randnumeric-и-randascii),
[randNumeric](#randalphanum-randalpha-randnumeric-и-randascii),
[repeat](#repeat), [replace](#replace), [shuffle](#shuffle),
[snakecase](#snakecase), [squote](#quote-и-squote), [substr](#substr),
[swapcase](#swapcase), [title](#title), [trim](#trim), [trimAll](#trimall),
[trimPrefix](#trimprefix), [trimSuffix](#trimsuffix), [trunc](#trunc),
[untitle](#untitle), [upper](#upper), [wrap](#wrap) и [wrapWith](#wrapwith).

### print

Возвращает строку из комбинации своих частей.

```
print "Matt has " .Dogs " dogs"
```

Типы, не являющиеся строками, преобразуются в строки, где это возможно.

Обратите внимание: когда два соседних аргумента не являются строками, между
ними добавляется пробел.

### println

Работает так же, как [print](#print), но добавляет новую строку в конце.

### printf

Возвращает строку на основе форматирующей строки и передаваемых ей аргументов
по порядку.

```
printf "%s has %d dogs." .Name .NumberDogs
```

Используемый заполнитель зависит от типа передаваемого аргумента.
Это включает:

Общего назначения:

* `%v` значение в формате по умолчанию
  * при выводе словарей флаг плюс (%+v) добавляет имена полей
* `%%` буквальный знак процента; не потребляет значение

Логические:

* `%t` слово true или false

Целочисленные:

* `%b` по основанию 2
* `%c` символ, соответствующий данной кодовой точке Unicode
* `%d` по основанию 10
* `%o` по основанию 8
* `%O` по основанию 8 с префиксом 0o
* `%q` символьный литерал в одинарных кавычках, безопасно экранированный
* `%x` по основанию 16 со строчными буквами a-f
* `%X` по основанию 16 с заглавными буквами A-F
* `%U` формат Unicode: U+1234; эквивалентно "U+%04X"

Для чисел с плавающей точкой и комплексных чисел:

* `%b` десятичная запись без научной нотации с показателем степени, являющимся
  степенью двойки, например -123456p-78
* `%e` научная нотация, например -1.234456e+78
* `%E` научная нотация, например -1.234456E+78
* `%f` десятичная точка без экспоненты, например 123.456
* `%F` синоним для %f
* `%g` %e для больших экспонент, %f в остальных случаях
* `%G` %E для больших экспонент, %F в остальных случаях
* `%x` шестнадцатеричная нотация (с десятичной степенью двойки), например
  -0x1.23abcp+20
* `%X` шестнадцатеричная нотация в верхнем регистре, например -0X1.23ABCP+20

Строки и срезы байтов (обрабатываются одинаково с этими спецификаторами):

* `%s` неинтерпретированные байты строки или среза
* `%q` строка в двойных кавычках, безопасно экранированная
* `%x` по основанию 16, нижний регистр, два символа на байт
* `%X` по основанию 16, верхний регистр, два символа на байт

Срезы:

* `%p` адрес 0-го элемента в шестнадцатеричной нотации с ведущим 0x

### trim

Функция `trim` удаляет пробельные символы с обеих сторон строки:

```
trim "   hello    "
```

Результат: `hello`

### trimAll

Удаляет указанные символы с начала и конца строки:

```
trimAll "$" "$5.00"
```

Результат: `5.00` (как строка).

### trimPrefix

Удаляет только префикс строки:

```
trimPrefix "-" "-hello"
```

Результат: `hello`

### trimSuffix

Удаляет только суффикс строки:

```
trimSuffix "-" "hello-"
```

Результат: `hello`

### lower

Преобразует всю строку в нижний регистр:

```
lower "HELLO"
```

Результат: `hello`

### upper

Преобразует всю строку в верхний регистр:

```
upper "hello"
```

Результат: `HELLO`

### title

Преобразует в заглавный регистр:

```
title "hello world"
```

Результат: `Hello World`

### untitle

Убирает заглавный регистр. `untitle "Hello World"` возвращает `hello world`.

### repeat

Повторяет строку несколько раз:

```
repeat 3 "hello"
```

Результат: `hellohellohello`

### substr

Получает подстроку из строки. Принимает три параметра:

- start (int)
- end (int)
- string (string)

```
substr 0 5 "hello world"
```

Результат: `hello`

### nospace

Удаляет все пробельные символы из строки.

```
nospace "hello w o r l d"
```

Результат: `helloworld`

### trunc

Обрезает строку

```
trunc 5 "hello world"
```

Результат: `hello`.

```
trunc -5 "hello world"
```

Выше возвращается `world`.

### abbrev

Обрезает строку с многоточием (`...`)

Параметры:

- максимальная длина
- строка

```
abbrev 5 "hello world"
```

Выше возвращается `he...`, так как ширина многоточия учитывается в
максимальной длине.

### abbrevboth

Сокращает с обеих сторон:

```
abbrevboth 5 10 "1234 5678 9123"
```

Выше возвращается `...5678...`

Принимает:

- смещение слева
- максимальную длину
- строку

### initials

При наличии нескольких слов берёт первую букву каждого слова и объединяет.

```
initials "First Try"
```

Результат: `FT`

### randAlphaNum, randAlpha, randNumeric и randAscii

Эти четыре функции генерируют криптографически безопасные (используют
```crypto/rand```) случайные строки с разными базовыми наборами символов:

- `randAlphaNum` использует `0-9a-zA-Z`
- `randAlpha` использует `a-zA-Z`
- `randNumeric` использует `0-9`
- `randAscii` использует все печатные ASCII-символы

Каждая из них принимает один параметр: целочисленную длину строки.

```
randNumeric 3
```

Выше возвращается случайная строка из трёх цифр.

### wrap

Переносит текст на заданное количество столбцов:

```
wrap 80 $someText
```

Выше переносит строку в `$someText` на 80 столбцах.

### wrapWith

`wrapWith` работает как `wrap`, но позволяет указать строку для переноса.
(`wrap` использует `\n`)

```
wrapWith 5 "\t" "Hello World"
```

Результат: `Hello World` (где пробельный символ — это ASCII-символ
табуляции)

### contains

Проверяет, содержится ли одна строка внутри другой:

```
contains "cat" "catch"
```

Результат: `true`, потому что `catch` содержит `cat`.

### hasPrefix и hasSuffix

Функции `hasPrefix` и `hasSuffix` проверяют, имеет ли строка заданный
префикс или суффикс:

```
hasPrefix "cat" "catch"
```

Результат: `true`, потому что `catch` имеет префикс `cat`.

### quote и squote

Эти функции оборачивают строку в двойные кавычки (`quote`) или одинарные
кавычки (`squote`).

### cat

Функция `cat` объединяет несколько строк в одну, разделяя их пробелами:

```
cat "hello" "beautiful" "world"
```

Результат: `hello beautiful world`

### indent

Функция `indent` добавляет отступ к каждой строке заданной строки на
указанную ширину отступа. Это полезно при выравнивании многострочных строк:

```
indent 4 $lots_of_text
```

Выше добавляет отступ в 4 пробела к каждой строке текста.

### nindent

Функция `nindent` аналогична функции indent, но добавляет новую строку
в начало.

```
nindent 4 $lots_of_text
```

Выше добавляет отступ в 4 пробела к каждой строке текста и добавляет новую
строку в начало.

### replace

Выполняет простую замену строки.

Принимает три аргумента:

- строку для замены
- строку для замены ею
- исходную строку

```
"I Am Henry VIII" | replace " " "-"
```

Результат: `I-Am-Henry-VIII`

### plural

Склоняет строку.

```
len $fish | plural "one anchovy" "many anchovies"
```

Выше, если длина строки равна 1, будет выведен первый аргумент (`one anchovy`).
В противном случае будет выведен второй аргумент (`many anchovies`).

Аргументы:

- строка единственного числа
- строка множественного числа
- целое число длины

ПРИМЕЧАНИЕ: Helm в настоящее время не поддерживает языки с более сложными
правилами склонения. И `0` считается множественным числом, потому что
английский язык обрабатывает его таким образом (`zero anchovies`).

### snakecase

Преобразует строку из camelCase в snake_case.

```
snakecase "FirstName"
```

Результат: `first_name`.

### camelcase

Преобразует строку из snake_case в CamelCase

```
camelcase "http_server"
```

Результат: `HttpServer`.

### kebabcase

Преобразует строку из camelCase в kebab-case.

```
kebabcase "FirstName"
```

Результат: `first-name`.

### swapcase

Меняет регистр строки с использованием алгоритма на основе слов.

Алгоритм преобразования:

- Символ верхнего регистра преобразуется в нижний регистр
- Символ титульного регистра преобразуется в нижний регистр
- Символ нижнего регистра после пробела или в начале преобразуется в
  титульный регистр
- Другие символы нижнего регистра преобразуются в верхний регистр
- Пробел определяется функцией unicode.IsSpace(char)

```
swapcase "This Is A.Test"
```

Результат: `tHIS iS a.tEST`.

### shuffle

Перемешивает строку.

```
shuffle "hello"
```

Выше перемешает буквы в `hello`, возможно возвращая `oelhl`.

## Функции преобразования типов

Helm предоставляет следующие функции преобразования типов:

- `atoi`: Преобразует строку в целое число.
- `float64`: Преобразует в `float64`.
- `int`: Преобразует в `int` системной разрядности.
- `int64`: Преобразует в `int64`.
- `toDecimal`: Преобразует восьмеричное число unix в `int64`.
- `toString`: Преобразует в строку.
- `toStrings`: Преобразует список, срез или массив в список строк.
- `toJson` (`mustToJson`): Преобразует список, срез, массив, словарь или
  объект в JSON.
- `toPrettyJson` (`mustToPrettyJson`): Преобразует список, срез, массив,
  словарь или объект в форматированный JSON с отступами.
- `toRawJson` (`mustToRawJson`): Преобразует список, срез, массив, словарь
  или объект в JSON с неэкранированными HTML-символами.
- `fromYaml`: Преобразует YAML-строку в объект.
- `fromJson`: Преобразует JSON-строку в объект.
- `fromJsonArray`: Преобразует JSON-массив в список.
- `toYaml`: Преобразует список, срез, массив, словарь или объект в
  форматированный yaml, может использоваться для копирования фрагментов yaml
  из любого источника. Эта функция эквивалентна функции GoLang yaml.Marshal,
  см. документацию: https://pkg.go.dev/gopkg.in/yaml.v2#Marshal
- `toYamlPretty`: Преобразует список, срез, массив, словарь или объект в
  форматированный yaml. Эквивалентно `toYaml`, но дополнительно добавляет
  отступ в 2 пробела для списков.
- `toToml`: Преобразует список, срез, массив, словарь или объект в toml,
  может использоваться для копирования фрагментов toml из любого источника.
- `fromYamlArray`: Преобразует YAML-массив в список.

Только `atoi` требует, чтобы входные данные были определённого типа. Остальные
попытаются преобразовать любой тип в целевой. Например, `int64` может
преобразовывать числа с плавающей точкой в целые числа, а также строки в
целые числа.

### toStrings

При наличии коллекции, похожей на список, возвращает срез строк.

```
list 1 2 3 | toStrings
```

Выше преобразует `1` в `"1"`, `2` в `"2"` и так далее, а затем возвращает их
как список.

### toDecimal

При наличии восьмеричного разрешения unix возвращает десятичное число.

```
"0777" | toDecimal
```

Выше преобразует `0777` в `511` и возвращает значение как int64.

### toJson, mustToJson

Функция `toJson` кодирует элемент в JSON-строку. Если элемент не может быть
преобразован в JSON, функция вернёт пустую строку. `mustToJson` вернёт
ошибку, если элемент не может быть закодирован в JSON.

```
toJson .Item
```

Выше возвращается строковое представление `.Item` в формате JSON.

### toPrettyJson, mustToPrettyJson

Функция `toPrettyJson` кодирует элемент в форматированную (с отступами)
JSON-строку.

```
toPrettyJson .Item
```

Выше возвращается форматированное строковое представление `.Item` в
формате JSON.

### toRawJson, mustToRawJson

Функция `toRawJson` кодирует элемент в JSON-строку с неэкранированными
HTML-символами.

```
toRawJson .Item
```

Выше возвращается неэкранированное строковое представление `.Item` в
формате JSON.

### fromYaml

Функция `fromYaml` принимает YAML-строку и возвращает объект, который
можно использовать в шаблонах.

`Файл: yamls/person.yaml`
```yaml
name: Bob
age: 25
hobbies:
  - hiking
  - fishing
  - cooking
```
```yaml
{{- $person := .Files.Get "yamls/person.yaml" | fromYaml }}
greeting: |
  Hi, my name is {{ $person.name }} and I am {{ $person.age }} years old.
  My hobbies are {{ range $person.hobbies }}{{ . }} {{ end }}.
```

### fromJson

Функция `fromJson` принимает JSON-строку и возвращает объект, который
можно использовать в шаблонах.

`Файл: jsons/person.json`
```json
{
  "name": "Bob",
  "age": 25,
  "hobbies": [
    "hiking",
    "fishing",
    "cooking"
  ]
}
```
```yaml
{{- $person := .Files.Get "jsons/person.json" | fromJson }}
greeting: |
  Hi, my name is {{ $person.name }} and I am {{ $person.age }} years old.
  My hobbies are {{ range $person.hobbies }}{{ . }} {{ end }}.
```


### fromJsonArray

Функция `fromJsonArray` принимает JSON-массив и возвращает список, который
можно использовать в шаблонах.

`Файл: jsons/people.json`
```json
[
 { "name": "Bob","age": 25 },
 { "name": "Ram","age": 16 }
]
```
```yaml
{{- $people := .Files.Get "jsons/people.json" | fromJsonArray }}
{{- range $person := $people }}
greeting: |
  Hi, my name is {{ $person.name }} and I am {{ $person.age }} years old.
{{ end }}
```

### toYaml, toYamlPretty

Функции `toYaml` и `toYamlPretty` кодируют объект (список, срез, массив,
словарь или объект) в форматированную YAML-строку.

> Обратите внимание, что `toYamlPretty` функционально эквивалентна, но выводит
> YAML с дополнительными отступами для элементов списка

```yaml
# toYaml
- name: bob
  age: 25
  hobbies:
  - hiking
  - fishing
  - cooking
```

```yaml
# toYamlPretty
- name: bob
  age: 25
  hobbies:
    - hiking
    - fishing
    - cooking
```

### fromYamlArray

Функция `fromYamlArray` принимает YAML-массив и возвращает список, который
можно использовать в шаблонах.

`Файл: yamls/people.yml`
```yaml
- name: Bob
  age: 25
- name: Ram
  age: 16
```
```yaml
{{- $people := .Files.Get "yamls/people.yml" | fromYamlArray }}
{{- range $person := $people }}
greeting: |
  Hi, my name is {{ $person.name }} and I am {{ $person.age }} years old.
{{ end }}
```


## Регулярные выражения

Helm включает следующие функции регулярных выражений: [regexFind
(mustRegexFind)](#regexfindall-mustregexfindall), [regexFindAll
(mustRegexFindAll)](#regexfind-mustregexfind), [regexMatch
(mustRegexMatch)](#regexmatch-mustregexmatch), [regexReplaceAll
(mustRegexReplaceAll)](#regexreplaceall-mustregexreplaceall),
[regexReplaceAllLiteral
(mustRegexReplaceAllLiteral)](#regexreplaceallliteral-mustregexreplaceallliteral),
[regexSplit (mustRegexSplit)](#regexsplit-mustregexsplit).

### regexMatch, mustRegexMatch

Возвращает true, если входная строка содержит любое совпадение с регулярным
выражением.

```
regexMatch "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$" "test@acme.com"
```

Результат: `true`

`regexMatch` вызывает панику при возникновении проблемы, а `mustRegexMatch`
возвращает ошибку в движок шаблонов при возникновении проблемы.

### regexFindAll, mustRegexFindAll

Возвращает срез всех совпадений регулярного выражения во входной строке.
Последний параметр n определяет количество возвращаемых подстрок, где -1
означает возврат всех совпадений.

```
regexFindAll "[2,4,6,8]" "123456789" -1
```

Выше возвращается `[2 4 6 8]`

`regexFindAll` вызывает панику при возникновении проблемы, а `mustRegexFindAll`
возвращает ошибку в движок шаблонов при возникновении проблемы.

### regexFind, mustRegexFind

Возвращает первое (самое левое) совпадение регулярного выражения во входной
строке.

```
regexFind "[a-zA-Z][1-9]" "abcd1234"
```

Выше возвращается `d1`

`regexFind` вызывает панику при возникновении проблемы, а `mustRegexFind`
возвращает ошибку в движок шаблонов при возникновении проблемы.

### regexReplaceAll, mustRegexReplaceAll

Возвращает копию входной строки, заменяя совпадения с регулярным выражением
строкой замены. Внутри строки замены знаки $ интерпретируются как в Expand,
поэтому, например, $1 представляет текст первого подсовпадения. Первый
аргумент — `<pattern>`, второй — `<input>`, третий — `<replacement>`.

```
regexReplaceAll "a(x*)b" "-ab-axxb-" "${1}W"
```

Выше возвращается `-W-xxW-`

`regexReplaceAll` вызывает панику при возникновении проблемы, а
`mustRegexReplaceAll` возвращает ошибку в движок шаблонов при возникновении
проблемы.

### regexReplaceAllLiteral, mustRegexReplaceAllLiteral

Возвращает копию входной строки, заменяя совпадения с регулярным выражением
строкой замены. Строка замены подставляется напрямую, без использования
Expand. Первый аргумент — `<pattern>`, второй — `<input>`, третий —
`<replacement>`.

```
regexReplaceAllLiteral "a(x*)b" "-ab-axxb-" "${1}"
```

Выше возвращается `-${1}-${1}-`

`regexReplaceAllLiteral` вызывает панику при возникновении проблемы, а
`mustRegexReplaceAllLiteral` возвращает ошибку в движок шаблонов при
возникновении проблемы.

### regexSplit, mustRegexSplit

Разбивает входную строку на подстроки, разделённые выражением, и возвращает
срез подстрок между совпадениями выражения. Последний параметр `n` определяет
количество возвращаемых подстрок, где `-1` означает возврат всех совпадений.

```
regexSplit "z+" "pizza" -1
```

Выше возвращается `[pi a]`

`regexSplit` вызывает панику при возникновении проблемы, а `mustRegexSplit`
возвращает ошибку в движок шаблонов при возникновении проблемы.

## Криптографические функции и функции безопасности

Helm предоставляет несколько продвинутых криптографических функций, включая
[adler32sum](#adler32sum), [buildCustomCert](#buildcustomcert),
[decryptAES](#decryptaes), [derivePassword](#derivepassword),
[encryptAES](#encryptaes), [genCA](#genca), [genPrivateKey](#genprivatekey),
[genSelfSignedCert](#genselfsignedcert), [genSignedCert](#gensignedcert),
[htpasswd](#htpasswd), [randBytes](#randbytes), [sha1sum](#sha1sum) и
[sha256sum](#sha256sum).

### sha1sum

Функция `sha1sum` получает строку и вычисляет её дайджест SHA1.

```
sha1sum "Hello world!"
```

### sha256sum

Функция `sha256sum` получает строку и вычисляет её дайджест SHA256.

```
sha256sum "Hello world!"
```

Выше вычисляется SHA 256 сумма в «ASCII armored» формате, который безопасен
для вывода.

### adler32sum

Функция `adler32sum` получает строку и вычисляет её контрольную сумму
Adler-32.

```
adler32sum "Hello world!"
```

### htpasswd

Функция `htpasswd` принимает `username` и `password` и генерирует
`bcrypt`-хэш пароля. Результат можно использовать для базовой аутентификации
на [сервере Apache HTTP](https://httpd.apache.org/docs/2.4/misc/password_encryptions.html#basic).

```
htpasswd "myUser" "myPassword"
```

Обратите внимание, что хранение пароля непосредственно в шаблоне небезопасно.

### randBytes

Функция randBytes принимает число N и генерирует криптографически безопасную
(использует crypto/rand) случайную последовательность из N байт.
Последовательность возвращается как строка в кодировке base64.

```
randBytes 24
```

### derivePassword

Функция `derivePassword` может использоваться для получения конкретного пароля
на основе некоторого общего «мастер-пароля» с ограничениями. Алгоритм для этого
[хорошо описан](https://web.archive.org/web/20211019121301/https://masterpassword.app/masterpassword-algorithm.pdf).

```
derivePassword 1 "long" "password" "user" "example.com"
```

Обратите внимание, что хранение частей непосредственно в шаблоне считается
небезопасным.

### genPrivateKey

Функция `genPrivateKey` генерирует новый закрытый ключ, закодированный в
блок PEM.

Принимает одно из значений в качестве первого параметра:

- `ecdsa`: Генерирует ключ эллиптической кривой DSA (P256)
- `dsa`: Генерирует ключ DSA (L2048N256)
- `rsa`: Генерирует ключ RSA 4096

### buildCustomCert

Функция `buildCustomCert` позволяет настроить сертификат.

Принимает следующие строковые параметры:

- Сертификат в формате PEM, закодированный в base64
- Закрытый ключ в формате PEM, закодированный в base64

Возвращает объект сертификата со следующими атрибутами:

- `Cert`: Сертификат в кодировке PEM
- `Key`: Закрытый ключ в кодировке PEM

Пример:

```
$ca := buildCustomCert "base64-encoded-ca-crt" "base64-encoded-ca-key"
```

Обратите внимание, что возвращённый объект можно передать в функцию
`genSignedCert` для подписания сертификата этим CA.

### genCA

Функция `genCA` генерирует новый самоподписанный центр сертификации x509.

Принимает следующие параметры:

- Common name субъекта (cn)
- Срок действия сертификата в днях

Возвращает объект со следующими атрибутами:

- `Cert`: Сертификат в кодировке PEM
- `Key`: Закрытый ключ в кодировке PEM

Пример:

```
$ca := genCA "foo-ca" 365
```

Обратите внимание, что возвращённый объект можно передать в функцию
`genSignedCert` для подписания сертификата этим CA.

### genSelfSignedCert

Функция `genSelfSignedCert` генерирует новый самоподписанный сертификат x509.

Принимает следующие параметры:

- Common name субъекта (cn)
- Необязательный список IP-адресов; может быть nil
- Необязательный список альтернативных DNS-имён; может быть nil
- Срок действия сертификата в днях

Возвращает объект со следующими атрибутами:

- `Cert`: Сертификат в кодировке PEM
- `Key`: Закрытый ключ в кодировке PEM

Пример:

```
$cert := genSelfSignedCert "foo.com" (list "10.0.0.1" "10.0.0.2") (list "bar.com" "bat.com") 365
```

### genSignedCert

Функция `genSignedCert` генерирует новый сертификат x509, подписанный
указанным CA.

Принимает следующие параметры:

- Common name субъекта (cn)
- Необязательный список IP-адресов; может быть nil
- Необязательный список альтернативных DNS-имён; может быть nil
- Срок действия сертификата в днях
- CA (см. `genCA`)

Пример:

```
$ca := genCA "foo-ca" 365
$cert := genSignedCert "foo.com" (list "10.0.0.1" "10.0.0.2") (list "bar.com" "bat.com") 365 $ca
```

### encryptAES

Функция `encryptAES` шифрует текст с помощью AES-256 CBC и возвращает строку
в кодировке base64.

```
encryptAES "secretkey" "plaintext"
```

### decryptAES

Функция `decryptAES` получает строку base64, закодированную алгоритмом
AES-256 CBC, и возвращает расшифрованный текст.

```
"30tEfhuJSVRhpG97XCuWgz2okj7L8vQ1s6V9zVUPeDQ=" | decryptAES "secretkey"
```

## Функции даты

Helm включает следующие функции даты, которые вы можете использовать в
шаблонах: [ago](#ago), [date](#date), [dateInZone](#dateinzone), [dateModify
(mustDateModify)](#datemodify-mustdatemodify), [duration](#duration),
[durationRound](#durationround), [htmlDate](#htmldate),
[htmlDateInZone](#htmldateinzone), [now](#now), [toDate
(mustToDate)](#todate-musttodate) и [unixEpoch](#unixepoch).

### now

Текущая дата/время. Используйте это в сочетании с другими функциями даты.

### ago

Функция `ago` возвращает продолжительность от текущего времени с разрешением
в секундах.

```
ago .CreatedAt
```

возвращает в формате `time.Duration` String()

```
2h34m7s
```

### date

Функция `date` форматирует дату.

Форматирует дату в формате ГОД-МЕСЯЦ-ДЕНЬ:

```
now | date "2006-01-02"
```

Форматирование даты в Go [немного
отличается](https://pauladamsmith.com/blog/2011/05/go_time.html).

Вкратце, возьмите это как базовую дату:

```
Mon Jan 2 15:04:05 MST 2006
```

Запишите её в нужном формате. Выше `2006-01-02` — это та же дата, но в
нужном нам формате.

### dateInZone

То же, что и `date`, но с часовым поясом.

```
dateInZone "2006-01-02" (now) "UTC"
```

### duration

Форматирует заданное количество секунд как `time.Duration`.

Результат: 1m35s

```
duration "95"
```

### durationRound

Округляет заданную продолжительность до наиболее значимой единицы. Строки и
`time.Duration` парсятся как продолжительность, а `time.Time` вычисляется
как продолжительность с того момента.

Результат: 2h

```
durationRound "2h10m5s"
```

Результат: 3mo

```
durationRound "2400h10m5s"
```

### unixEpoch

Возвращает количество секунд с начала эпохи unix для `time.Time`.

```
now | unixEpoch
```

### dateModify, mustDateModify

`dateModify` принимает модификацию и дату и возвращает метку времени.

Вычесть час и тридцать минут из текущего времени:

```
now | dateModify "-1.5h"
```

Если формат модификации неверен, `dateModify` вернёт дату без изменений.
`mustDateModify` вернёт ошибку в противном случае.

### htmlDate

Функция `htmlDate` форматирует дату для вставки в поле ввода выбора даты HTML.

```
now | htmlDate
```

### htmlDateInZone

То же, что и htmlDate, но с часовым поясом.

```
htmlDateInZone (now) "UTC"
```

### toDate, mustToDate

`toDate` преобразует строку в дату. Первый аргумент — это формат даты,
второй — строка даты. Если строка не может быть преобразована, возвращается
нулевое значение. `mustToDate` вернёт ошибку, если строка не может быть
преобразована.

Это полезно, когда вы хотите преобразовать строковую дату в другой формат
(используя конвейер). Пример ниже преобразует "2017-12-31" в "31/12/2017".

```
toDate "2006-01-02" "2017-12-31" | date "02/01/2006"
```

## Словари и функции Dict

Helm предоставляет тип хранения ключ/значение, называемый `dict` (сокращение
от «dictionary», как в Python). `dict` — это _неупорядоченный_ тип.

Ключом словаря **должна быть строка**. Однако значением может быть любой
тип, даже другой `dict` или `list`.

В отличие от `list`, `dict` не является неизменяемым. Функции `set` и `unset`
будут изменять содержимое словаря.

Helm предоставляет следующие функции для работы со словарями: [deepCopy
(mustDeepCopy)](#deepcopy-mustdeepcopy), [dict](#dict), [dig](#dig), [get](#get),
[hasKey](#haskey), [keys](#keys), [merge (mustMerge)](#merge-mustmerge),
[mergeOverwrite (mustMergeOverwrite)](#mergeoverwrite-mustmergeoverwrite),
[omit](#omit), [pick](#pick), [pluck](#pluck), [set](#set), [unset](#unset) и
[values](#values).

### dict

Создание словарей выполняется вызовом функции `dict` с передачей списка пар.

Следующее создаёт словарь с тремя элементами:

```
$myDict := dict "name1" "value1" "name2" "value2" "name3" "value 3"
```

### get

При наличии map и ключа получает значение из map.

```
get $myDict "name1"
```

Вернёт `"value1"`

Обратите внимание, что если ключ не найден, операция просто вернёт `""`.
Ошибка не будет сгенерирована.

### set

Используйте `set` для добавления новой пары ключ/значение в словарь.

```
$_ := set $myDict "name4" "value4"
```

Обратите внимание, что `set` _возвращает словарь_ (требование функций
шаблонов Go), поэтому вам может потребоваться перехватить значение, как
показано выше с присваиванием `$_`.

### unset

При наличии map и ключа удаляет ключ из map.

```
$_ := unset $myDict "name4"
```

Как и `set`, это возвращает словарь.

Обратите внимание, что если ключ не найден, операция просто вернётся.
Ошибка не будет сгенерирована.

### hasKey

Функция `hasKey` возвращает `true`, если данный словарь содержит данный ключ.

```
hasKey $myDict "name1"
```

Если ключ не найден, возвращается `false`.

### pluck

Функция `pluck` позволяет задать один ключ и несколько map и получить список
всех совпадений:

```
pluck "name1" $myDict $myOtherDict
```

Выше вернётся `list`, содержащий каждое найденное значение (`[value1
otherValue1]`).

Если данный ключ _не найден_ в map, этот map не будет иметь элемента в списке
(и длина возвращённого списка будет меньше количества словарей в вызове
`pluck`).

Если ключ _найден_, но значение является пустым, это значение будет вставлено.

Распространённая идиома в шаблонах Helm — использовать `pluck... | first`
для получения первого совпадающего ключа из коллекции словарей.

### dig

Функция `dig` проходит по вложенному набору словарей, выбирая ключи из
списка значений. Возвращает значение по умолчанию, если какой-либо из ключей
не найден в соответствующем словаре.

```
dig "user" "role" "humanName" "guest" $dict
```

При наличии словаря со структурой
```
{
  user: {
    role: {
      humanName: "curator"
    }
  }
}
```

выше вернётся `"curator"`. Если в словаре отсутствует даже поле `user`,
результатом будет `"guest"`.

Dig может быть очень полезен в случаях, когда вы хотите избежать защитных
условий, особенно учитывая, что `and` в пакете шаблонов Go не использует
короткое замыкание. Например, `and a.maybeNil a.maybeNil.iNeedThis` всегда
будет вычислять `a.maybeNil.iNeedThis` и вызовет панику, если у `a`
отсутствует поле `maybeNil`.)

`dig` принимает аргумент словаря последним для поддержки конвейеров.
Например:
```
merge a b c | dig "one" "two" "three" "<missing>"
```

### merge, mustMerge

Объединяет два или более словарей в один, отдавая приоритет целевому
словарю:

При наличии:

```
dest:
  default: default
  overwrite: me
  key: true

src:
  overwrite: overwritten
  key: false
```

результатом будет:

```
newdict:
  default: default
  overwrite: me
  key: true
```
```
$newdict := merge $dest $source1 $source2
```

Это операция глубокого объединения, но не глубокого копирования. Вложенные
объекты, которые объединяются, являются одним и тем же экземпляром в обоих
словарях. Если вы хотите глубокое копирование вместе с объединением,
используйте функцию `deepCopy` вместе с объединением. Например,

```
deepCopy $source | merge $dest
```

`mustMerge` вернёт ошибку в случае неудачного объединения.

### mergeOverwrite, mustMergeOverwrite

Объединяет два или более словарей в один, отдавая приоритет **справа налево**,
фактически перезаписывая значения в целевом словаре:

При наличии:

```
dest:
  default: default
  overwrite: me
  key: true

src:
  overwrite: overwritten
  key: false
```

результатом будет:

```
newdict:
  default: default
  overwrite: overwritten
  key: false
```

```
$newdict := mergeOverwrite $dest $source1 $source2
```

Это операция глубокого объединения, но не глубокого копирования. Вложенные
объекты, которые объединяются, являются одним и тем же экземпляром в обоих
словарях. Если вы хотите глубокое копирование вместе с объединением,
используйте функцию `deepCopy` вместе с объединением. Например,

```
deepCopy $source | mergeOverwrite $dest
```

`mustMergeOverwrite` вернёт ошибку в случае неудачного объединения.

### keys

Функция `keys` вернёт `list` всех ключей в одном или нескольких типах
`dict`. Поскольку словарь _неупорядочен_, ключи не будут в предсказуемом
порядке. Их можно отсортировать с помощью `sortAlpha`.

```
keys $myDict | sortAlpha
```

При передаче нескольких словарей ключи будут объединены. Используйте
функцию `uniq` вместе с `sortAlpha` для получения уникального
отсортированного списка ключей.

```
keys $myDict $myOtherDict | uniq | sortAlpha
```

### pick

Функция `pick` выбирает только указанные ключи из словаря, создавая новый
`dict`.

```
$new := pick $myDict "name1" "name2"
```

Выше возвращается `{name1: value1, name2: value2}`

### omit

Функция `omit` похожа на `pick`, но возвращает новый `dict` со всеми
ключами, которые _не соответствуют_ указанным ключам.

```
$new := omit $myDict "name1" "name3"
```

Выше возвращается `{name2: value2}`

### values

Функция `values` похожа на `keys`, но возвращает новый `list` со всеми
значениями исходного `dict` (поддерживается только один словарь).

```
$vals := values $myDict
```

Выше возвращается `list["value1", "value2", "value 3"]`. Обратите внимание,
что функция `values` не гарантирует порядок результата; если это важно,
используйте `sortAlpha`.

### deepCopy, mustDeepCopy

Функции `deepCopy` и `mustDeepCopy` принимают значение и делают его глубокую
копию. Это включает словари и другие структуры. `deepCopy` вызывает панику
при возникновении проблемы, а `mustDeepCopy` возвращает ошибку в систему
шаблонов при возникновении ошибки.

```
dict "a" 1 "b" 2 | deepCopy
```

### Примечание о внутренней реализации Dict

`dict` реализован в Go как `map[string]interface{}`. Разработчики Go могут
передавать значения `map[string]interface{}` в контекст, чтобы сделать их
доступными для шаблонов как `dict`.

## Функции кодирования

Helm имеет следующие функции кодирования и декодирования:

- `b64enc`/`b64dec`: Кодирование или декодирование с помощью Base64
- `b32enc`/`b32dec`: Кодирование или декодирование с помощью Base32

## Списки и функции List

Helm предоставляет простой тип `list`, который может содержать произвольные
последовательные списки данных. Это похоже на массивы или срезы, но списки
разработаны для использования как неизменяемые типы данных.

Создание списка целых чисел:

```
$myList := list 1 2 3 4 5
```

Выше создаётся список `[1 2 3 4 5]`.

Helm предоставляет следующие функции списков: [append
(mustAppend)](#append-mustappend), [chunk](#chunk), [compact
(mustCompact)](#compact-mustcompact), [concat](#concat), [first
(mustFirst)](#first-mustfirst), [has (mustHas)](#has-musthas), [initial
(mustInitial)](#initial-mustinitial), [last (mustLast)](#last-mustlast),
[prepend (mustPrepend)](#prepend-mustprepend), [rest
(mustRest)](#rest-mustrest), [reverse (mustReverse)](#reverse-mustreverse),
[seq](#seq), [index](#index), [slice (mustSlice)](#slice-mustslice), [uniq
(mustUniq)](#uniq-mustuniq), [until](#until), [untilStep](#untilstep) и
[without (mustWithout)](#without-mustwithout).

### first, mustFirst

Чтобы получить первый элемент списка, используйте `first`.

`first $myList` возвращает `1`

`first` вызывает панику при возникновении проблемы, а `mustFirst` возвращает
ошибку в движок шаблонов при возникновении проблемы.

### rest, mustRest

Чтобы получить хвост списка (всё, кроме первого элемента), используйте `rest`.

`rest $myList` возвращает `[2 3 4 5]`

`rest` вызывает панику при возникновении проблемы, а `mustRest` возвращает
ошибку в движок шаблонов при возникновении проблемы.

### last, mustLast

Чтобы получить последний элемент списка, используйте `last`:

`last $myList` возвращает `5`. Это примерно аналогично обращению списка и
последующему вызову `first`.

### initial, mustInitial

Это дополняет `last`, возвращая всё, _кроме_ последнего элемента. `initial
$myList` возвращает `[1 2 3 4]`.

`initial` вызывает панику при возникновении проблемы, а `mustInitial`
возвращает ошибку в движок шаблонов при возникновении проблемы.

### append, mustAppend

Добавляет новый элемент в существующий список, создавая новый список.

```
$new = append $myList 6
```

Выше установит `$new` в `[1 2 3 4 5 6]`. `$myList` останется неизменным.

`append` вызывает панику при возникновении проблемы, а `mustAppend`
возвращает ошибку в движок шаблонов при возникновении проблемы.

### prepend, mustPrepend

Добавляет элемент в начало списка, создавая новый список.

```
prepend $myList 0
```

Выше вернёт `[0 1 2 3 4 5]`. `$myList` останется неизменным.

`prepend` вызывает панику при возникновении проблемы, а `mustPrepend`
возвращает ошибку в движок шаблонов при возникновении проблемы.

### concat

Объединяет произвольное количество списков в один.

```
concat $myList ( list 6 7 ) ( list 8 )
```

Выше вернёт `[1 2 3 4 5 6 7 8]`. `$myList` останется неизменным.

### reverse, mustReverse

Создаёт новый список с обратным порядком элементов данного списка.

```
reverse $myList
```

Выше сгенерирует список `[5 4 3 2 1]`.

`reverse` вызывает панику при возникновении проблемы, а `mustReverse`
возвращает ошибку в движок шаблонов при возникновении проблемы.

### uniq, mustUniq

Генерирует список с удалением всех дубликатов.

```
list 1 1 1 2 | uniq
```

Выше вернёт `[1 2]`

`uniq` вызывает панику при возникновении проблемы, а `mustUniq` возвращает
ошибку в движок шаблонов при возникновении проблемы.

### without, mustWithout

Функция `without` отфильтровывает элементы из списка.

```
without $myList 3
```

Выше вернёт `[1 2 4 5]`

`without` может принимать более одного фильтра:

```
without $myList 1 3 5
```

Это вернёт `[2 4]`

`without` вызывает панику при возникновении проблемы, а `mustWithout`
возвращает ошибку в движок шаблонов при возникновении проблемы.

### has, mustHas

Проверяет, содержит ли список определённый элемент.

```
has 4 $myList
```

Выше вернёт `true`, тогда как `has "hello" $myList` вернёт false.

`has` вызывает панику при возникновении проблемы, а `mustHas` возвращает
ошибку в движок шаблонов при возникновении проблемы.

### compact, mustCompact

Принимает список и удаляет записи с пустыми значениями.

```
$list := list 1 "a" "foo" ""
$copy := compact $list
```

`compact` вернёт новый список с удалённым пустым (т.е. "") элементом.

`compact` вызывает панику при возникновении проблемы, а `mustCompact`
возвращает ошибку в движок шаблонов при возникновении проблемы.

### index

Чтобы получить n-й элемент списка, используйте `index list [n]`. Для
индексации многомерных списков используйте `index list [n] [m] ...`
- `index $myList 0` возвращает `1`. Это то же самое, что `myList[0]`
- `index $myList 0 1` было бы эквивалентно `myList[0][1]`

### slice, mustSlice

Чтобы получить частичные элементы списка, используйте `slice list [n] [m]`.
Это эквивалентно `list[n:m]`.

- `slice $myList` возвращает `[1 2 3 4 5]`. Это то же самое, что `myList[:]`.
- `slice $myList 3` возвращает `[4 5]`. Это то же самое, что `myList[3:]`.
- `slice $myList 1 3` возвращает `[2 3]`. Это то же самое, что `myList[1:3]`.
- `slice $myList 0 3` возвращает `[1 2 3]`. Это то же самое, что `myList[:3]`.

`slice` вызывает панику при возникновении проблемы, а `mustSlice` возвращает
ошибку в движок шаблонов при возникновении проблемы.

### until

Функция `until` создаёт диапазон целых чисел.

```
until 5
```

Выше генерируется список `[0, 1, 2, 3, 4]`.

Это полезно для циклов с `range $i, $e := until 5`.

### untilStep

Как и `until`, `untilStep` генерирует список счётных целых чисел. Но позволяет
определить начало, конец и шаг:

```
untilStep 3 6 2
```

Выше вернёт `[3 5]`, начиная с 3 и прибавляя 2, пока значение не станет равным
или больше 6. Это похоже на функцию `range` в Python.

### seq

Работает как команда bash `seq`.

* 1 параметр (end) - сгенерирует все счётные целые числа от 1 до `end`
  включительно.
* 2 параметра (start, end) - сгенерирует все счётные целые числа от `start`
  до `end` включительно с шагом 1 или -1.
* 3 параметра (start, step, end) - сгенерирует все счётные целые числа от
  `start` до `end` включительно с указанным `step`.

```
seq 5       => 1 2 3 4 5
seq -3      => 1 0 -1 -2 -3
seq 0 2     => 0 1 2
seq 2 -2    => 2 1 0 -1 -2
seq 0 2 10  => 0 2 4 6 8 10
seq 0 -2 -5 => 0 -2 -4
```

### chunk

Чтобы разбить список на части заданного размера, используйте `chunk size list`.
Это полезно для пагинации.

```
chunk 3 (list 1 2 3 4 5 6 7 8)
```

Это создаёт список списков `[ [ 1 2 3 ] [ 4 5 6 ] [ 7 8 ] ]`.

## Математические функции

Все математические функции работают со значениями `int64`, если не указано
иное.

Доступны следующие математические функции: [add](#add), [add1](#add1),
[ceil](#ceil), [div](#div), [floor](#floor), [len](#len), [max](#max),
[min](#min), [mod](#mod), [mul](#mul), [round](#round) и [sub](#sub).

### add

Суммирует числа с помощью `add`. Принимает два или более входных значения.

```
add 1 2 3
```

### add1

Чтобы увеличить на 1, используйте `add1`.

### sub

Для вычитания используйте `sub`.

### div

Выполняет целочисленное деление с помощью `div`.

### mod

Остаток от деления с помощью `mod`.

### mul

Умножает с помощью `mul`. Принимает два или более входных значения.

```
mul 1 2 3
```

### max

Возвращает наибольшее из серии целых чисел.

Это вернёт `3`:

```
max 1 2 3
```

### min

Возвращает наименьшее из серии целых чисел.

`min 1 2 3` вернёт `1`.

### len

Возвращает длину аргумента как целое число.

```
len .Arg
```

## Математические функции с плавающей точкой

Все математические функции работают со значениями `float64`.

### addf

Суммирует числа с помощью `addf`

Это вернёт `5.5`:

```
addf 1.5 2 2
```

### add1f

Чтобы увеличить на 1, используйте `add1f`

### subf

Для вычитания используйте `subf`

Это эквивалентно `7.5 - 2 - 3` и вернёт `2.5`:

```
subf 7.5 2 3
```

### divf

Выполняет деление с плавающей точкой с помощью `divf`

Это эквивалентно `10 / 2 / 4` и вернёт `1.25`:

```
divf 10 2 4
```

### mulf

Умножает с помощью `mulf`

Это вернёт `6`:

```
mulf 1.5 2 2
```

### maxf

Возвращает наибольшее из серии чисел с плавающей точкой:

Это вернёт `3`:

```
maxf 1 2.5 3
```

### minf

Возвращает наименьшее из серии чисел с плавающей точкой.

Это вернёт `1.5`:

```
minf 1.5 2 3
```

### floor

Возвращает наибольшее значение с плавающей точкой, меньшее или равное
входному значению.

`floor 123.9999` вернёт `123.0`.

### ceil

Возвращает наименьшее значение с плавающей точкой, большее или равное
входному значению.

`ceil 123.001` вернёт `124.0`.

### round

Возвращает значение с плавающей точкой с остатком, округлённым до указанного
количества цифр после десятичной точки.

`round 123.555555 3` вернёт `123.556`.

## Сетевые функции

Helm имеет одну сетевую функцию, `getHostByName`.

`getHostByName` получает доменное имя и возвращает IP-адрес.

`getHostByName "www.google.com"` вернёт соответствующий IP-адрес
`www.google.com`.

Эта функция требует передачи опции `--enable-dns` в командной строке helm.

## Функции путей файлов

Хотя функции шаблонов Helm не предоставляют доступа к файловой системе, они
предоставляют функции для работы со строками, которые следуют соглашениям
о путях файлов. К ним относятся [base](#base), [clean](#clean), [dir](#dir),
[ext](#ext) и [isAbs](#isabs).

### base

Возвращает последний элемент пути.

```
base "foo/bar/baz"
```

Выше выводится "baz".

### dir

Возвращает директорию, удаляя последнюю часть пути. Так `dir
"foo/bar/baz"` возвращает `foo/bar`.

### clean

Очищает путь.

```
clean "foo/bar/../baz"
```

Выше разрешается `..` и возвращается `foo/baz`.

### ext

Возвращает расширение файла.

```
ext "foo.bar"
```

Выше возвращается `.bar`.

### isAbs

Чтобы проверить, является ли путь файла абсолютным, используйте `isAbs`.

## Функции рефлексии

Helm предоставляет базовые инструменты рефлексии. Они помогают продвинутым
разработчикам шаблонов понять информацию о базовом типе Go для конкретного
значения. Helm написан на Go и является строго типизированным. Система типов
применяется внутри шаблонов.

Go имеет несколько примитивных _видов_ (kinds), таких как `string`, `slice`,
`int64` и `bool`.

Go имеет открытую _систему типов_, которая позволяет разработчикам создавать
собственные типы.

Helm предоставляет набор функций для каждого через [функции kind](#функции-kind)
и [функции type](#функции-type). Также предоставляется функция [deepEqual](#deepequal)
для сравнения двух значений.

### Функции Kind

Существует две функции Kind: `kindOf` возвращает вид объекта.

```
kindOf "hello"
```

Выше вернёт `string`. Для простых тестов (например, в блоках `if`) функция
`kindIs` позволит вам проверить, что значение является определённым видом:

```
kindIs "int" 123
```

Выше вернёт `true`.

### Функции Type

С типами немного сложнее работать, поэтому существует три разные функции:

- `typeOf` возвращает базовый тип значения: `typeOf $foo`
- `typeIs` похож на `kindIs`, но для типов: `typeIs "*io.Buffer" $myVal`
- `typeIsLike` работает как `typeIs`, но также разыменовывает указатели

**Примечание:** Ни одна из этих функций не может проверить, реализует ли
что-то данный интерфейс, так как для этого потребовалось бы скомпилировать
интерфейс заранее.

### deepEqual

`deepEqual` возвращает true, если два значения ["глубоко
равны"](https://golang.org/pkg/reflect/#DeepEqual)

Работает и для непримитивных типов (в отличие от встроенного `eq`).

```
deepEqual (list 1 2 3) (list 1 2 3)
```

Выше вернёт `true`.

## Функции семантических версий

Некоторые схемы версионирования легко парсятся и сравниваются. Helm
предоставляет функции для работы с версиями [SemVer 2](http://semver.org).
К ним относятся [semver](#semver) и [semverCompare](#semvercompare). Ниже
вы также найдёте подробности об использовании диапазонов для сравнений.

### semver

Функция `semver` парсит строку в семантическую версию:

```
$version := semver "1.2.3-alpha.1+123"
```

_Если парсер завершится с ошибкой, это приведёт к остановке выполнения
шаблона с ошибкой._

На этом этапе `$version` является указателем на объект `Version` со следующими
свойствами:

- `$version.Major`: Мажорный номер (`1` выше)
- `$version.Minor`: Минорный номер (`2` выше)
- `$version.Patch`: Номер патча (`3` выше)
- `$version.Prerelease`: Пререлиз (`alpha.1` выше)
- `$version.Metadata`: Метаданные сборки (`123` выше)
- `$version.Original`: Оригинальная версия как строка

Кроме того, вы можете сравнить `Version` с другой `version`, используя
функцию `Compare`:

```
semver "1.4.3" | (semver "1.2.3").Compare
```

Выше вернёт `-1`.

Возвращаемые значения:

- `-1` если данный semver больше, чем semver, метод `Compare` которого
  был вызван
- `1` если версия, чья функция `Compare` была вызвана, больше
- `0` если это одна и та же версия

(Обратите внимание, что в SemVer поле `Metadata` не сравнивается при
операциях сравнения версий.)

### semverCompare

Более надёжная функция сравнения предоставляется как `semverCompare`.
Эта версия поддерживает диапазоны версий:

- `semverCompare "1.2.3" "1.2.3"` проверяет на точное совпадение
- `semverCompare "~1.2.0" "1.2.3"` проверяет, что мажорная и минорная версии
  совпадают, и что номер патча второго параметра _больше или равен_ первому
  параметру.

Функции SemVer используют [библиотеку semver от
Masterminds](https://github.com/Masterminds/semver), от создателей Sprig.

### Базовые сравнения

В сравнениях есть два элемента. Во-первых, строка сравнения — это список
сравнений И, разделённых пробелами или запятыми. Затем они разделяются
|| (ИЛИ). Например, `">= 1.2 < 3.0.0 || >= 4.2.3"` ищет сравнение, которое
больше или равно 1.2 и меньше 3.0.0 или больше или равно 4.2.3.

Базовые сравнения:

- `=`: равно (синоним отсутствия оператора)
- `!=`: не равно
- `>`: больше чем
- `<`: меньше чем
- `>=`: больше или равно
- `<=`: меньше или равно

### Работа с пререлизными версиями

Пререлизы, для тех, кто не знаком с ними, используются для релизов
программного обеспечения до стабильного или общедоступного релиза.
Примерами пререлизов являются релизы development, alpha, beta и release
candidate. Пререлиз может быть версией, такой как `1.2.3-beta.1`, тогда как
стабильный релиз будет `1.2.3`. В порядке приоритета пререлизы идут перед
связанными с ними релизами. В этом примере `1.2.3-beta.1 < 1.2.3`.

Согласно спецификации семантического версионирования, пререлизы могут не
быть API-совместимыми со своим релизным аналогом. Она гласит:

> Пререлизная версия указывает, что версия нестабильна и может не
> удовлетворять предполагаемым требованиям совместимости, обозначенным её
> соответствующей нормальной версией.

Сравнения SemVer с использованием ограничений без компаратора пререлиза
будут пропускать пререлизные версии. Например, `>=1.2.3` пропустит
пререлизы при просмотре списка релизов, тогда как `>=1.2.3-0` оценит и
найдёт пререлизы.

Причина `0` в качестве пререлизной версии в примере сравнения в том, что
пререлизы могут содержать только ASCII буквенно-цифровые символы и дефисы
(вместе с разделителями `.`), согласно спецификации. Сортировка происходит
в порядке ASCII, снова согласно спецификации. Наименьший символ — `0` в
порядке сортировки ASCII (см. [таблицу
ASCII](http://www.asciitable.com/))

Понимание порядка сортировки ASCII важно, потому что A-Z идёт перед a-z.
Это означает, что `>=1.2.3-BETA` вернёт `1.2.3-alpha`. То, что вы могли бы
ожидать от чувствительности к регистру, здесь не применяется. Это связано с
порядком сортировки ASCII, который указан в спецификации.

### Сравнения с диапазонами через дефис

Существует несколько методов работы с диапазонами, и первый — это диапазоны
через дефис. Они выглядят так:

- `1.2 - 1.4.5` что эквивалентно `>= 1.2 <= 1.4.5`
- `2.3.4 - 4.5` что эквивалентно `>= 2.3.4 <= 4.5`

### Подстановочные знаки в сравнениях

Символы `x`, `X` и `*` могут использоваться как подстановочный знак. Это
работает для всех операторов сравнения. При использовании с оператором `=`
он возвращается к сравнению на уровне патча (см. тильду ниже). Например,

- `1.2.x` эквивалентно `>= 1.2.0, < 1.3.0`
- `>= 1.2.x` эквивалентно `>= 1.2.0`
- `<= 2.x` эквивалентно `< 3`
- `*` эквивалентно `>= 0.0.0`

### Сравнения с диапазоном тильды (Patch)

Оператор сравнения тильда (`~`) предназначен для диапазонов на уровне патча,
когда указана минорная версия, и изменений на уровне мажорной версии, когда
минорный номер отсутствует. Например,

- `~1.2.3` эквивалентно `>= 1.2.3, < 1.3.0`
- `~1` эквивалентно `>= 1, < 2`
- `~2.3` эквивалентно `>= 2.3, < 2.4`
- `~1.2.x` эквивалентно `>= 1.2.0, < 1.3.0`
- `~1.x` эквивалентно `>= 1, < 2`

### Сравнения с диапазоном каретки (Major)

Оператор сравнения каретка (`^`) предназначен для изменений на уровне
мажорной версии после выхода стабильного релиза (1.0.0). До релиза 1.0.0
минорные версии действуют как уровень стабильности API. Это полезно при
сравнении версий API, так как мажорное изменение ломает API. Например,

- `^1.2.3` эквивалентно `>= 1.2.3, < 2.0.0`
- `^1.2.x` эквивалентно `>= 1.2.0, < 2.0.0`
- `^2.3` эквивалентно `>= 2.3, < 3`
- `^2.x` эквивалентно `>= 2.0.0, < 3`
- `^0.2.3` эквивалентно `>=0.2.3 <0.3.0`
- `^0.2` эквивалентно `>=0.2.0 <0.3.0`
- `^0.0.3` эквивалентно `>=0.0.3 <0.0.4`
- `^0.0` эквивалентно `>=0.0.0 <0.1.0`
- `^0` эквивалентно `>=0.0.0 <1.0.0`

## URL-функции

Helm включает функции [urlParse](#urlparse), [urlJoin](#urljoin) и
[urlquery](#urlquery), позволяющие работать с частями URL.

### urlParse

Парсит строку для URL и возвращает словарь с частями URL

```
urlParse "http://admin:secret@server.com:8080/api?list=false#anchor"
```

Выше возвращается словарь, содержащий объект URL:

```yaml
scheme:   'http'
host:     'server.com:8080'
path:     '/api'
query:    'list=false'
opaque:   nil
fragment: 'anchor'
userinfo: 'admin:secret'
```

Это реализовано с использованием пакетов URL из стандартной библиотеки Go.
Для дополнительной информации см. https://golang.org/pkg/net/url/#URL

### urlJoin

Объединяет map (созданный `urlParse`) для создания строки URL

```
urlJoin (dict "fragment" "fragment" "host" "host:80" "path" "/path" "query" "query" "scheme" "http")
```

Выше возвращается следующая строка:
```
http://host:80/path?query#fragment
```

### urlquery

Возвращает экранированную версию переданного значения, чтобы его можно было
безопасно встроить в запросную часть URL.

```
$var := urlquery "string for query"
```

## UUID-функции

Helm может генерировать универсально уникальные идентификаторы UUID v4.

```
uuidv4
```

Выше возвращается новый UUID типа v4 (случайно сгенерированный).

## Функции Kubernetes и Chart

Helm включает функции для работы с Kubernetes, включая
[.Capabilities.APIVersions.Has](#capabilitiesapiversionshas),
[Files](#функции-files) и [lookup](#lookup).

### lookup

`lookup` используется для поиска ресурса в работающем кластере. При
использовании с командой `helm template` всегда возвращается пустой ответ.

Вы можете найти более подробную информацию в [документации по функции
lookup](./functions_and_pipelines.md#использование-функции-lookup).

### .Capabilities.APIVersions.Has

Возвращает, доступна ли версия API или ресурс в кластере.

```
.Capabilities.APIVersions.Has "apps/v1"
.Capabilities.APIVersions.Has "apps/v1/Deployment"
```

Дополнительная информация доступна в [документации по встроенным
объектам](./builtin_objects.md).

### Функции Files

Существует несколько функций, которые позволяют получить доступ к
неспециальным файлам внутри chart. Например, для доступа к файлам
конфигурации приложения. Они документированы в [Доступ к файлам внутри
шаблонов](./accessing_files.md).

_Примечание: документация для многих из этих функций взята из
[Sprig](https://github.com/Masterminds/sprig). Sprig — это библиотека
функций шаблонов, доступная для приложений Go._
